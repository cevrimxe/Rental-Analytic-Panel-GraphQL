package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"
	"rental-analytics/graph/model"
	"time"
)

// TopCustomers is the resolver for the topCustomers field.
func (r *queryResolver) TopCustomers(ctx context.Context, limit *int32, startDate *time.Time, endDate *time.Time) ([]*model.CustomerStats, error) {
	// Varsayılan limit değeri
	if limit == nil {
		defaultLimit := int32(10)
		limit = &defaultLimit
	}

	query := `
		SELECT 
			c.customer_id,
			c.first_name,
			c.last_name,
			c.email,
			COALESCE(SUM(p.amount), 0) as total_spent,
			COUNT(r.rental_id) as rentals_count
		FROM customer c
		LEFT JOIN rental r ON c.customer_id = r.customer_id
		LEFT JOIN payment p ON r.rental_id = p.rental_id
	`

	args := []interface{}{}
	whereClause := ""

	// Tarih filtresi ekle
	if startDate != nil && endDate != nil {
		whereClause = " WHERE r.rental_date BETWEEN $1 AND $2"
		args = append(args, *startDate, *endDate)
	} else if startDate != nil {
		whereClause = " WHERE r.rental_date >= $1"
		args = append(args, *startDate)
	} else if endDate != nil {
		whereClause = " WHERE r.rental_date <= $1"
		args = append(args, *endDate)
	}

	query += whereClause + `
		GROUP BY c.customer_id, c.first_name, c.last_name, c.email
		ORDER BY total_spent DESC
		LIMIT $` + fmt.Sprintf("%d", len(args)+1)

	args = append(args, *limit)

	rows, err := r.DB.Query(query, args...)
	if err != nil {
		return nil, fmt.Errorf("veritabanı sorgusu hatası: %w", err)
	}
	defer rows.Close()

	var customerStats []*model.CustomerStats
	for rows.Next() {
		var customer model.Customer
		var totalSpent float64
		var rentalsCount int32

		err := rows.Scan(
			&customer.ID,
			&customer.FirstName,
			&customer.LastName,
			&customer.Email,
			&totalSpent,
			&rentalsCount,
		)
		if err != nil {
			return nil, fmt.Errorf("satır okuma hatası: %w", err)
		}

		customerStats = append(customerStats, &model.CustomerStats{
			Customer:     &customer,
			TotalSpent:   totalSpent,
			RentalsCount: rentalsCount,
		})
	}

	return customerStats, nil
}

// StoreRevenue is the resolver for the storeRevenue field.
func (r *queryResolver) StoreRevenue(ctx context.Context, startDate *time.Time, endDate *time.Time) ([]*model.StoreStats, error) {
	query := `
		SELECT 
			s.store_id,
			a.address,
			COALESCE(SUM(p.amount), 0) as total_revenue,
			COUNT(r.rental_id) as rentals_count
		FROM store s
		JOIN address a ON s.address_id = a.address_id
		LEFT JOIN inventory i ON s.store_id = i.store_id
		LEFT JOIN rental r ON i.inventory_id = r.inventory_id
		LEFT JOIN payment p ON r.rental_id = p.rental_id
	`

	args := []interface{}{}
	whereClause := ""

	// Tarih filtresi ekle
	if startDate != nil && endDate != nil {
		whereClause = " WHERE r.rental_date BETWEEN $1 AND $2"
		args = append(args, *startDate, *endDate)
	} else if startDate != nil {
		whereClause = " WHERE r.rental_date >= $1"
		args = append(args, *startDate)
	} else if endDate != nil {
		whereClause = " WHERE r.rental_date <= $1"
		args = append(args, *endDate)
	}

	query += whereClause + `
		GROUP BY s.store_id, a.address
		ORDER BY total_revenue DESC`

	rows, err := r.DB.Query(query, args...)
	if err != nil {
		return nil, fmt.Errorf("veritabanı sorgusu hatası: %w", err)
	}
	defer rows.Close()

	var storeStats []*model.StoreStats
	for rows.Next() {
		var store model.Store
		var totalRevenue float64
		var rentalsCount int32

		err := rows.Scan(
			&store.ID,
			&store.Address,
			&totalRevenue,
			&rentalsCount,
		)
		if err != nil {
			return nil, fmt.Errorf("satır okuma hatası: %w", err)
		}

		storeStats = append(storeStats, &model.StoreStats{
			Store:        &store,
			TotalRevenue: totalRevenue,
			RentalsCount: rentalsCount,
		})
	}

	return storeStats, nil
}

// MostRentedFilms is the resolver for the mostRentedFilms field.
func (r *queryResolver) MostRentedFilms(ctx context.Context, limit *int32, category *string) ([]*model.FilmStats, error) {
	// Varsayılan limit değeri
	if limit == nil {
		defaultLimit := int32(10)
		limit = &defaultLimit
	}

	query := `
		SELECT 
			f.film_id,
			f.title,
			f.description,
			STRING_AGG(DISTINCT c.name, ', ') as category,
			COUNT(DISTINCT r.rental_id) as rentals_count,
			COALESCE(SUM(DISTINCT p.amount), 0) as total_revenue
		FROM film f
		JOIN film_category fc ON f.film_id = fc.film_id
		JOIN category c ON fc.category_id = c.category_id
		LEFT JOIN inventory i ON f.film_id = i.film_id
		LEFT JOIN rental r ON i.inventory_id = r.inventory_id
		LEFT JOIN payment p ON r.rental_id = p.rental_id
	`

	args := []interface{}{}
	whereClause := ""

	// Kategori filtresi ekle
	if category != nil && *category != "" {
		whereClause = " WHERE c.name = $1"
		args = append(args, *category)
	}

	query += whereClause + `
		GROUP BY f.film_id, f.title, f.description
		ORDER BY rentals_count DESC
		LIMIT $` + fmt.Sprintf("%d", len(args)+1)

	args = append(args, *limit)

	rows, err := r.DB.Query(query, args...)
	if err != nil {
		return nil, fmt.Errorf("veritabanı sorgusu hatası: %w", err)
	}
	defer rows.Close()

	var filmStats []*model.FilmStats
	for rows.Next() {
		var film model.Film
		var rentalsCount int32
		var totalRevenue float64

		err := rows.Scan(
			&film.ID,
			&film.Title,
			&film.Description,
			&film.Category,
			&rentalsCount,
			&totalRevenue,
		)
		if err != nil {
			return nil, fmt.Errorf("satır okuma hatası: %w", err)
		}

		filmStats = append(filmStats, &model.FilmStats{
			Film:         &film,
			RentalsCount: rentalsCount,
			TotalRevenue: totalRevenue,
		})
	}

	return filmStats, nil
}

// ActiveRentals is the resolver for the activeRentals field.
func (r *queryResolver) ActiveRentals(ctx context.Context) ([]*model.Rental, error) {
	query := `
		SELECT 
			r.rental_id,
			r.rental_date,
			r.return_date,
			c.customer_id,
			c.first_name,
			c.last_name,
			c.email,
			f.film_id,
			f.title,
			f.description,
			cat.name as category,
			s.store_id,
			a.address
		FROM rental r
		JOIN customer c ON r.customer_id = c.customer_id
		JOIN inventory i ON r.inventory_id = i.inventory_id
		JOIN film f ON i.film_id = f.film_id
		JOIN film_category fc ON f.film_id = fc.film_id
		JOIN category cat ON fc.category_id = cat.category_id
		JOIN store s ON i.store_id = s.store_id
		JOIN address a ON s.address_id = a.address_id
		WHERE r.return_date IS NULL
		ORDER BY r.rental_date DESC
		LIMIT 50`

	rows, err := r.DB.Query(query)
	if err != nil {
		return nil, fmt.Errorf("veritabanı sorgusu hatası: %w", err)
	}
	defer rows.Close()

	var rentals []*model.Rental
	for rows.Next() {
		var rental model.Rental
		var customer model.Customer
		var film model.Film
		var store model.Store

		err := rows.Scan(
			&rental.ID,
			&rental.RentalDate,
			&rental.ReturnDate,
			&customer.ID,
			&customer.FirstName,
			&customer.LastName,
			&customer.Email,
			&film.ID,
			&film.Title,
			&film.Description,
			&film.Category,
			&store.ID,
			&store.Address,
		)
		if err != nil {
			return nil, fmt.Errorf("satır okuma hatası: %w", err)
		}

		rental.Customer = &customer
		rental.Film = &film
		rental.Store = &store
		rental.IsLate = false // Aktif kiralamalar için geç kalma durumu ayrı hesaplanabilir

		rentals = append(rentals, &rental)
	}

	return rentals, nil
}

// LateRentals is the resolver for the lateRentals field.
func (r *queryResolver) LateRentals(ctx context.Context) ([]*model.Rental, error) {
	query := `
		SELECT 
			r.rental_id,
			r.rental_date,
			r.return_date,
			c.customer_id,
			c.first_name,
			c.last_name,
			c.email,
			f.film_id,
			f.title,
			f.description,
			cat.name as category,
			s.store_id,
			a.address
		FROM rental r
		JOIN customer c ON r.customer_id = c.customer_id
		JOIN inventory i ON r.inventory_id = i.inventory_id
		JOIN film f ON i.film_id = f.film_id
		JOIN film_category fc ON f.film_id = fc.film_id
		JOIN category cat ON fc.category_id = cat.category_id
		JOIN store s ON i.store_id = s.store_id
		JOIN address a ON s.address_id = a.address_id
		WHERE r.return_date IS NULL 
		  AND r.rental_date + INTERVAL '7 days' < NOW()
		ORDER BY r.rental_date ASC`

	rows, err := r.DB.Query(query)
	if err != nil {
		return nil, fmt.Errorf("veritabanı sorgusu hatası: %w", err)
	}
	defer rows.Close()

	var rentals []*model.Rental
	for rows.Next() {
		var rental model.Rental
		var customer model.Customer
		var film model.Film
		var store model.Store

		err := rows.Scan(
			&rental.ID,
			&rental.RentalDate,
			&rental.ReturnDate,
			&customer.ID,
			&customer.FirstName,
			&customer.LastName,
			&customer.Email,
			&film.ID,
			&film.Title,
			&film.Description,
			&film.Category,
			&store.ID,
			&store.Address,
		)
		if err != nil {
			return nil, fmt.Errorf("satır okuma hatası: %w", err)
		}

		rental.Customer = &customer
		rental.Film = &film
		rental.Store = &store
		rental.IsLate = true

		rentals = append(rentals, &rental)
	}

	return rentals, nil
}

// TotalRevenue is the resolver for the totalRevenue field.
func (r *queryResolver) TotalRevenue(ctx context.Context, startDate *time.Time, endDate *time.Time) (float64, error) {
	query := "SELECT COALESCE(SUM(amount), 0) FROM payment p JOIN rental r ON p.rental_id = r.rental_id"
	args := []interface{}{}

	// Tarih filtresi ekle
	if startDate != nil && endDate != nil {
		query += " WHERE r.rental_date BETWEEN $1 AND $2"
		args = append(args, *startDate, *endDate)
	} else if startDate != nil {
		query += " WHERE r.rental_date >= $1"
		args = append(args, *startDate)
	} else if endDate != nil {
		query += " WHERE r.rental_date <= $1"
		args = append(args, *endDate)
	}

	var totalRevenue float64
	err := r.DB.QueryRow(query, args...).Scan(&totalRevenue)
	if err != nil {
		return 0, fmt.Errorf("veritabanı sorgusu hatası: %w", err)
	}

	return totalRevenue, nil
}

// TotalCustomers is the resolver for the totalCustomers field.
func (r *queryResolver) TotalCustomers(ctx context.Context) (int32, error) {
	var count int32
	err := r.DB.QueryRow("SELECT COUNT(*) FROM customer").Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("veritabanı sorgusu hatası: %w", err)
	}
	return count, nil
}

// TotalFilms is the resolver for the totalFilms field.
func (r *queryResolver) TotalFilms(ctx context.Context) (int32, error) {
	var count int32
	err := r.DB.QueryRow("SELECT COUNT(*) FROM film").Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("veritabanı sorgusu hatası: %w", err)
	}
	return count, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
